package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

func parseTag(text string) (out []*MarkerField) {
	text = strings.TrimSpace(strings.TrimPrefix(text, "//"))
	if strings.HasPrefix(text, "json:") {
		text = text[5:]
		pairs := strings.Split(text, ",")
		for _, p := range pairs {
			if kv := strings.SplitN(strings.TrimSpace(p), "=", 2); len(kv) == 2 && kv[0] != "" && kv[1] != "" {
				f := MarkerField{
					Field: kv[0],
					Value: kv[1],
				}
				if f.Value[0] == '"' {
					f.Const = true
				}
				out = append(out, &f)
			}
		}
	}
	return
}

type MarkerField struct {
	Field string
	Value string
	Const bool
}

type structSpec struct {
	Name           string
	TypeParamNames string
	TypeParams     string
	Markers        []*MarkerField
}

func collectTypeParams(ts *ast.TypeSpec, fset *token.FileSet) (names []string, withTypes []string, err error) {
	if ts.TypeParams != nil {
		for _, field := range ts.TypeParams.List {
			var n []string
			for _, name := range field.Names {
				n = append(n, name.Name)
			}
			names = append(names, n...)
			var typeParams strings.Builder
			if err = format.Node(&typeParams, fset, field.Type); err != nil {
				return nil, nil, err
			}
			withTypes = append(withTypes, strings.Join(n, " ")+" "+typeParams.String())
		}
	}
	return
}

func collectSpecs(pkg *ast.Package, fset *token.FileSet) ([]*structSpec, error) {
	var specs []*structSpec
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			// filter struct declarations
			if decl, ok := decl.(*ast.GenDecl); ok {
				if decl.Doc != nil {
					var markers []*MarkerField
					for _, comment := range decl.Doc.List {
						markers = parseTag(comment.Text)
						if markers != nil {
							break
						}
					}
					if markers != nil && len(decl.Specs) == 1 {
						if ts, ok := decl.Specs[0].(*ast.TypeSpec); ok {
							names, withTypes, err := collectTypeParams(ts, fset)
							if err != nil {
								return nil, err
							}
							specs = append(specs, &structSpec{
								Name:           ts.Name.Name,
								Markers:        markers,
								TypeParamNames: strings.Join(names, ", "),
								TypeParams:     strings.Join(withTypes, ", "),
							})
						}
					}
				}
			}
		}
	}
	return specs, nil
}

const tplSrc = `package {{.Package}}

import "encoding/json"

// Code generated by genmarshaller.go DO NOT EDIT.
{{range .Specs}}
func (self *{{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}) MarshalJSON() ([]byte, error) {
	type {{.Name}}_no_json_marshaller {{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}

	type json_{{.Name}} struct {
		{{range $i, $m := .Markers -}}
		Marker{{$i}} any {{tag $m.Field}}
		{{end -}}
		{{.Name}}_no_json_marshaller
	}

	tmp := json_{{.Name}} {
		{{range $i, $m := .Markers -}}
		Marker{{$i}}: {{if not $m.Const}}self.{{end}}{{$m.Value}},
		{{end -}}
		{{.Name}}_no_json_marshaller: {{.Name}}_no_json_marshaller(*self),
	}

	return json.Marshal(tmp)
}
{{end}}
`

var tpl = template.Must(template.New("json_gen").Funcs(template.FuncMap{
	"tag": func(x string) string { return fmt.Sprintf("`json:\"%s\"`", x) },
}).Parse(tplSrc))

const outName = "json_gen.go"

type tplData struct {
	Package string
	Specs   []*structSpec
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) == 0 {
		log.Fatal("no packages found")
	} else if len(pkgs) != 1 {
		log.Fatal("more than one package found")
	}

	var pkg *ast.Package
	for _, v := range pkgs {
		pkg = v
		break
	}

	specs, err := collectSpecs(pkg, fset)
	if err != nil {
		log.Fatal(err)
	}

	data := tplData{
		Specs:   specs,
		Package: pkg.Name,
	}

	fd, err := os.Create(outName)
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()
	if err = tpl.Execute(fd, &data); err != nil {
		log.Fatal(err)
	}
}
