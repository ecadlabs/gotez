package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

func parseTag(text string) (field, value string) {
	text = strings.TrimSpace(strings.TrimPrefix(text, "//"))
	if strings.HasPrefix(text, "json:") {
		if kv := strings.SplitN(text[5:], "=", 2); len(kv) == 2 && kv[0] != "" && kv[1] != "" {
			return kv[0], kv[1]
		}
	}
	return
}

type structSpec struct {
	Name           string
	TypeParamNames string
	TypeParams     string
	Field          string
	Value          string
}

func collectTypeParams(ts *ast.TypeSpec, fset *token.FileSet) (names []string, withTypes []string, err error) {
	if ts.TypeParams != nil {
		for _, field := range ts.TypeParams.List {
			var n []string
			for _, name := range field.Names {
				n = append(n, name.Name)
			}
			names = append(names, n...)
			var typeParams strings.Builder
			if err = format.Node(&typeParams, fset, field.Type); err != nil {
				return nil, nil, err
			}
			withTypes = append(withTypes, strings.Join(n, " ")+" "+typeParams.String())
		}
	}
	return
}

func collectSpecs(pkg *ast.Package, fset *token.FileSet) ([]*structSpec, error) {
	var specs []*structSpec
	for _, file := range pkg.Files {
		for _, decl := range file.Decls {
			// filter struct declarations
			if decl, ok := decl.(*ast.GenDecl); ok {
				if decl.Doc != nil {
					var (
						field, value string
					)
					for _, comment := range decl.Doc.List {
						field, value = parseTag(comment.Text)
						if field != "" {
							break
						}
					}
					if field != "" && len(decl.Specs) == 1 {
						if ts, ok := decl.Specs[0].(*ast.TypeSpec); ok {
							if _, ok := ts.Type.(*ast.StructType); ok {
								names, withTypes, err := collectTypeParams(ts, fset)
								if err != nil {
									return nil, err
								}
								specs = append(specs, &structSpec{
									Name:           ts.Name.Name,
									Field:          field,
									Value:          value,
									TypeParamNames: strings.Join(names, ", "),
									TypeParams:     strings.Join(withTypes, ", "),
								})
							}
						}
					}
				}
			}
		}
	}
	return specs, nil
}

/*
const tplSrc = `package {{.Package}}

import "encoding/json"

// Code generated by genmarshaller.go DO NOT EDIT.
{{range .Specs}}
func (self *{{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}) MarshalJSON() ([]byte, error) {
	type {{.Name}}_json_suppress {{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}

	type {{.Name}}_json struct {
		Marker string {{tag .Field}}
		*{{.Name}}_json_suppress
	}

	tmp := {{.Name}}_json {
		Marker: "{{.Value}}",
		{{.Name}}_json_suppress: (*{{.Name}}_json_suppress)(self),
	}

	return json.Marshal(&tmp)
}

{{end}}
`
*/

const tplSrc = `package {{.Package}}

import "encoding/json"

// Code generated by genmarshaller.go DO NOT EDIT.
{{range .Specs}}
type json_suppress_{{.Name}}{{with .TypeParams}}[{{.}}]{{end}} {{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}

func (self *{{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}}) MarshalJSON() ([]byte, error) {
	buf, err := json.Marshal((*json_suppress_{{.Name}}{{with .TypeParamNames}}[{{.}}]{{end}})(self))
	if err != nil {
		return nil, err
	}

	var tmp map[string]any
	if err = json.Unmarshal(buf, &tmp); err != nil {
		return nil, err
	}

	tmp["{{.Field}}"] = "{{.Value}}"
	return json.Marshal(tmp)
}

{{end}}
`

var tpl = template.Must(template.New("json_gen").Funcs(template.FuncMap{
	"tag": func(x string) string { return fmt.Sprintf("`json:\"%s\"`", x) },
}).Parse(tplSrc))

const outName = "json_gen.go"

type tplData struct {
	Package string
	Specs   []*structSpec
}

func main() {
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) == 0 {
		log.Fatal("no packages found")
	} else if len(pkgs) != 1 {
		log.Fatal("more than one package found")
	}

	var pkg *ast.Package
	for _, v := range pkgs {
		pkg = v
		break
	}

	specs, err := collectSpecs(pkg, fset)
	if err != nil {
		log.Fatal(err)
	}

	data := tplData{
		Specs:   specs,
		Package: pkg.Name,
	}

	fd, err := os.Create(outName)
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()
	if err = tpl.Execute(fd, &data); err != nil {
		log.Fatal(err)
	}
}
