package gotez

import "fmt"

// Code generated by generate.go DO NOT EDIT.

type BlockHash [BlockHashBytesLen]byte

func (self *BlockHash) String() string {
	return string(self.Base58())
}

func (self *BlockHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxBlockHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewBlockHashFromBase58(src []byte) (*BlockHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxBlockHash {
		return nil, fmt.Errorf("gotez: invalid BlockHash encoding")
	}
	var out BlockHash
	copy(out[:], payload)
	return &out, nil
}

type OperationsHash [OperationListListHashBytesLen]byte

func (self *OperationsHash) String() string {
	return string(self.Base58())
}

func (self *OperationsHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxOperationListListHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewOperationsHashFromBase58(src []byte) (*OperationsHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxOperationListListHash {
		return nil, fmt.Errorf("gotez: invalid OperationsHash encoding")
	}
	var out OperationsHash
	copy(out[:], payload)
	return &out, nil
}

type ContextHash [ContextHashBytesLen]byte

func (self *ContextHash) String() string {
	return string(self.Base58())
}

func (self *ContextHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxContextHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewContextHashFromBase58(src []byte) (*ContextHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxContextHash {
		return nil, fmt.Errorf("gotez: invalid ContextHash encoding")
	}
	var out ContextHash
	copy(out[:], payload)
	return &out, nil
}

type BlockPayloadHash [BlockPayloadHashBytesLen]byte

func (self *BlockPayloadHash) String() string {
	return string(self.Base58())
}

func (self *BlockPayloadHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxValueHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewBlockPayloadHashFromBase58(src []byte) (*BlockPayloadHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxValueHash {
		return nil, fmt.Errorf("gotez: invalid BlockPayloadHash encoding")
	}
	var out BlockPayloadHash
	copy(out[:], payload)
	return &out, nil
}

type CycleNonceHash [CycleNonceBytesLen]byte

func (self *CycleNonceHash) String() string {
	return string(self.Base58())
}

func (self *CycleNonceHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxCycleNonce, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewCycleNonceHashFromBase58(src []byte) (*CycleNonceHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxCycleNonce {
		return nil, fmt.Errorf("gotez: invalid CycleNonceHash encoding")
	}
	var out CycleNonceHash
	copy(out[:], payload)
	return &out, nil
}

type Signature [GenericSignatureBytesLen]byte

func (self *Signature) String() string {
	return string(self.Base58())
}

func (self *Signature) Base58() []byte {
	out, err := EncodeTZBase58(&PfxGenericSignature, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewSignatureFromBase58(src []byte) (*Signature, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxGenericSignature {
		return nil, fmt.Errorf("gotez: invalid Signature encoding")
	}
	var out Signature
	copy(out[:], payload)
	return &out, nil
}

type Ed25519PublicKeyHash [PKHBytesLen]byte

func (self *Ed25519PublicKeyHash) String() string {
	return string(self.Base58())
}

func (self *Ed25519PublicKeyHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxEd25519PublicKeyHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewEd25519PublicKeyHashFromBase58(src []byte) (*Ed25519PublicKeyHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxEd25519PublicKeyHash {
		return nil, fmt.Errorf("gotez: invalid Ed25519PublicKeyHash encoding")
	}
	var out Ed25519PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

type Secp256k1PublicKeyHash [PKHBytesLen]byte

func (self *Secp256k1PublicKeyHash) String() string {
	return string(self.Base58())
}

func (self *Secp256k1PublicKeyHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxSecp256k1PublicKeyHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewSecp256k1PublicKeyHashFromBase58(src []byte) (*Secp256k1PublicKeyHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxSecp256k1PublicKeyHash {
		return nil, fmt.Errorf("gotez: invalid Secp256k1PublicKeyHash encoding")
	}
	var out Secp256k1PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

type P256PublicKeyHash [PKHBytesLen]byte

func (self *P256PublicKeyHash) String() string {
	return string(self.Base58())
}

func (self *P256PublicKeyHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxP256PublicKeyHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewP256PublicKeyHashFromBase58(src []byte) (*P256PublicKeyHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxP256PublicKeyHash {
		return nil, fmt.Errorf("gotez: invalid P256PublicKeyHash encoding")
	}
	var out P256PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

type BLSPublicKeyHash [PKHBytesLen]byte

func (self *BLSPublicKeyHash) String() string {
	return string(self.Base58())
}

func (self *BLSPublicKeyHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxBLS12_381PublicKeyHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewBLSPublicKeyHashFromBase58(src []byte) (*BLSPublicKeyHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxBLS12_381PublicKeyHash {
		return nil, fmt.Errorf("gotez: invalid BLSPublicKeyHash encoding")
	}
	var out BLSPublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

type ProtocolHash [ProtocolHashBytesLen]byte

func (self *ProtocolHash) String() string {
	return string(self.Base58())
}

func (self *ProtocolHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxProtocolHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewProtocolHashFromBase58(src []byte) (*ProtocolHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxProtocolHash {
		return nil, fmt.Errorf("gotez: invalid ProtocolHash encoding")
	}
	var out ProtocolHash
	copy(out[:], payload)
	return &out, nil
}

type ContractHash [ContractHashBytesLen]byte

func (self *ContractHash) String() string {
	return string(self.Base58())
}

func (self *ContractHash) Base58() []byte {
	out, err := EncodeTZBase58(&PfxContractHash, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewContractHashFromBase58(src []byte) (*ContractHash, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxContractHash {
		return nil, fmt.Errorf("gotez: invalid ContractHash encoding")
	}
	var out ContractHash
	copy(out[:], payload)
	return &out, nil
}

type Ed25519PublicKey [Ed25519PublicKeyBytesLen]byte

func (self *Ed25519PublicKey) String() string {
	return string(self.Base58())
}

func (self *Ed25519PublicKey) Base58() []byte {
	out, err := EncodeTZBase58(&PfxEd25519PublicKey, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewEd25519PublicKeyFromBase58(src []byte) (*Ed25519PublicKey, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxEd25519PublicKey {
		return nil, fmt.Errorf("gotez: invalid Ed25519PublicKey encoding")
	}
	var out Ed25519PublicKey
	copy(out[:], payload)
	return &out, nil
}

type Secp256k1PublicKey [Secp256K1PublicKeyBytesLen]byte

func (self *Secp256k1PublicKey) String() string {
	return string(self.Base58())
}

func (self *Secp256k1PublicKey) Base58() []byte {
	out, err := EncodeTZBase58(&PfxSecp256k1PublicKey, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewSecp256k1PublicKeyFromBase58(src []byte) (*Secp256k1PublicKey, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxSecp256k1PublicKey {
		return nil, fmt.Errorf("gotez: invalid Secp256k1PublicKey encoding")
	}
	var out Secp256k1PublicKey
	copy(out[:], payload)
	return &out, nil
}

type P256PublicKey [P256PublicKeyBytesLen]byte

func (self *P256PublicKey) String() string {
	return string(self.Base58())
}

func (self *P256PublicKey) Base58() []byte {
	out, err := EncodeTZBase58(&PfxP256PublicKey, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewP256PublicKeyFromBase58(src []byte) (*P256PublicKey, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxP256PublicKey {
		return nil, fmt.Errorf("gotez: invalid P256PublicKey encoding")
	}
	var out P256PublicKey
	copy(out[:], payload)
	return &out, nil
}

type BLSPublicKey [BLSPublicKeyBytesLen]byte

func (self *BLSPublicKey) String() string {
	return string(self.Base58())
}

func (self *BLSPublicKey) Base58() []byte {
	out, err := EncodeTZBase58(&PfxBLS12_381PublicKey, self[:])
	if err != nil {
		panic(err)
	}
	return out
}

func NewBLSPublicKeyFromBase58(src []byte) (*BLSPublicKey, error) {
	prefix, payload, err := DecodeTZBase58(src)
	if err != nil {
		return nil, err
	}
	if prefix != &PfxBLS12_381PublicKey {
		return nil, fmt.Errorf("gotez: invalid BLSPublicKey encoding")
	}
	var out BLSPublicKey
	copy(out[:], payload)
	return &out, nil
}

