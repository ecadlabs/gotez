package client

import (
	"context"
	"strings"
	"text/template"
)

// Code generated by generate.go DO NOT EDIT.

var path_BlockHeader = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/header"))

func (client *Client) BlockHeader(ctx context.Context, r *BlockRequest) (BlockHeaderInfo, error) {
	var path strings.Builder
	if err := path_BlockHeader.Execute(&path, r); err != nil {
		return nil, err
	}
	params := map[string]any{
		"metadata": r.Metadata,
	}
	response, err := newBlockHeaderInfo(r.Protocol)
	if err != nil {
		return nil, err
	}
	if err := client.request(ctx, "GET", path.String(), params, nil, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_Block = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}"))

func (client *Client) Block(ctx context.Context, r *BlockRequest) (BlockInfo, error) {
	var path strings.Builder
	if err := path_Block.Execute(&path, r); err != nil {
		return nil, err
	}
	params := map[string]any{
		"metadata": r.Metadata,
	}
	response, err := newBlockInfo(r.Protocol)
	if err != nil {
		return nil, err
	}
	if err := client.request(ctx, "GET", path.String(), params, nil, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_BlockShellHeader = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/header/shell"))

func (client *Client) BlockShellHeader(ctx context.Context, r *BlockRequest) (*BlockShellHeader, error) {
	var path strings.Builder
	if err := path_BlockShellHeader.Execute(&path, r); err != nil {
		return nil, err
	}
	response := new(BlockShellHeader)
	if err := client.request(ctx, "GET", path.String(), nil, nil, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_ContractBalance = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/balance"))

func (client *Client) ContractBalance(ctx context.Context, r *ContractRequest) (BigUint, error) {
	var path strings.Builder
	if err := path_ContractBalance.Execute(&path, r); err != nil {
		return nil, err
	}
	var response BigUint
	if err := client.request(ctx, "GET", path.String(), nil, nil, &response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_ContractBalanceAndFrozenBonds = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/balance_and_frozen_bonds"))

func (client *Client) ContractBalanceAndFrozenBonds(ctx context.Context, r *ContractRequest) (BigUint, error) {
	var path strings.Builder
	if err := path_ContractBalanceAndFrozenBonds.Execute(&path, r); err != nil {
		return nil, err
	}
	var response BigUint
	if err := client.request(ctx, "GET", path.String(), nil, nil, &response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_ContractCounter = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/counter"))

func (client *Client) ContractCounter(ctx context.Context, r *ContractRequest) (BigUint, error) {
	var path strings.Builder
	if err := path_ContractCounter.Execute(&path, r); err != nil {
		return nil, err
	}
	var response BigUint
	if err := client.request(ctx, "GET", path.String(), nil, nil, &response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_RunOperation = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/helpers/scripts/run_operation"))

func (client *Client) RunOperation(ctx context.Context, r *RunOperationRequest) (*OperationWithOptionalMetadata, error) {
	var path strings.Builder
	if err := path_RunOperation.Execute(&path, r); err != nil {
		return nil, err
	}
	payload := r.Payload
	response := new(OperationWithOptionalMetadata)
	if err := client.request(ctx, "POST", path.String(), nil, payload, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_Constants = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/context/constants"))

func (client *Client) Constants(ctx context.Context, r *ContextRequest) (Constants, error) {
	var path strings.Builder
	if err := path_Constants.Execute(&path, r); err != nil {
		return nil, err
	}
	response, err := newConstants(r.Protocol)
	if err != nil {
		return nil, err
	}
	if err := client.request(ctx, "GET", path.String(), nil, nil, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_InjectOperation = template.Must(template.New("path").Parse("/injection/operation"))

func (client *Client) InjectOperation(ctx context.Context, r *InjectOperationRequest) (*OperationHash, error) {
	var path strings.Builder
	if err := path_InjectOperation.Execute(&path, r); err != nil {
		return nil, err
	}
	params := map[string]any{
		"async": r.Async,
		"chain": r.Chain,
	}
	payload := r.Payload
	response := new(OperationHash)
	if err := client.request(ctx, "POST", path.String(), params, payload, response); err != nil {
		return nil, err
	}
	return response, nil
}

var path_BlockProtocols = template.Must(template.New("path").Parse("/chains/{{.Chain}}/blocks/{{.Block}}/protocols"))

func (client *Client) BlockProtocols(ctx context.Context, r *BlockRequest) (*BlockProtocols, error) {
	var path strings.Builder
	if err := path_BlockProtocols.Execute(&path, r); err != nil {
		return nil, err
	}
	response := new(BlockProtocols)
	if err := client.request(ctx, "GET", path.String(), nil, nil, response); err != nil {
		return nil, err
	}
	return response, nil
}

