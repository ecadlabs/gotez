//go:build ignore

package main

import (
	"log"
	"os"
	"text/template"
)

const (
	ModeVar int = iota
	ModeConstruct
	ModeAllocate
)

type queryParam struct {
	Field string
	Param string
}

type typeDef struct {
	Func         string
	RequestType  string
	Path         string
	QueryParams  map[string]string
	Method       string
	ResponseType string
	AllocMode    int
	Stream       bool
}

var types = []*typeDef{
	{
		RequestType:  "SimpleRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/hash",
		Func:         "BlockHash",
		ResponseType: "BlockHash",
		AllocMode:    ModeAllocate,
	},
	{
		RequestType:  "SimpleRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/protocols",
		Func:         "BlockProtocols",
		ResponseType: "BlockProtocols",
		AllocMode:    ModeAllocate,
	},
	{
		RequestType:  "SimpleRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/header/shell",
		Func:         "BlockShellHeader",
		ResponseType: "BlockShellHeader",
		AllocMode:    ModeAllocate,
	},
	{
		RequestType:  "BlockRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/header",
		QueryParams:  map[string]string{"metadata": "Metadata"},
		Func:         "BlockHeader",
		ResponseType: "BlockHeaderInfo",
		AllocMode:    ModeConstruct,
	},
	{
		RequestType:  "BlockRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}",
		QueryParams:  map[string]string{"metadata": "Metadata"},
		Func:         "Block",
		ResponseType: "BlockInfo",
		AllocMode:    ModeConstruct,
	},
	{
		RequestType:  "ContractRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/balance",
		Func:         "ContractBalance",
		ResponseType: "BigUint",
		AllocMode:    ModeVar,
	},
	{
		RequestType:  "ContractRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/balance_and_frozen_bonds",
		Func:         "ContractBalanceAndFrozenBonds",
		ResponseType: "BigUint",
		AllocMode:    ModeVar,
	},
	{
		RequestType:  "ContractRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/context/contracts/{{.ID}}/counter",
		Func:         "ContractCounter",
		ResponseType: "BigUint",
		AllocMode:    ModeVar,
	},
	{
		RequestType:  "RunOperationRequest",
		Method:       "POST",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/helpers/scripts/run_operation",
		Func:         "RunOperation",
		ResponseType: "OperationWithOptionalMetadata",
		AllocMode:    ModeAllocate,
	},
	{
		RequestType:  "ContextRequest",
		Method:       "GET",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}/context/constants",
		Func:         "Constants",
		ResponseType: "Constants",
		AllocMode:    ModeConstruct,
	},
	{
		RequestType:  "InjectOperationRequest",
		Method:       "POST",
		Path:         "/injection/operation",
		QueryParams:  map[string]string{"chain": "Chain", "async": "Async"},
		Func:         "InjectOperation",
		ResponseType: "OperationHash",
		AllocMode:    ModeAllocate,
	},
	{
		Stream:       true,
		RequestType:  "HeadsRequest",
		Path:         "/monitor/heads/{{.Chain}}",
		QueryParams:  map[string]string{"protocol": "Protocol", "next_protocol": "NextProtocol"},
		Func:         "Heads",
		ResponseType: "Head",
	},
}

const tplSrc = `package client

import (
	"context"
	"strings"
	"text/template"
)

// Code generated by generate.go DO NOT EDIT.
{{range .}}
var path_{{.Func}} = template.Must(template.New("path").Parse("{{.Path}}"))

func (client *Client) {{.Func}}(ctx context.Context, r *{{.RequestType}}) ({{if .Stream}}<-chan *{{.ResponseType}}, <-chan error{{else}}{{if eq .AllocMode 2}}*{{end}}{{.ResponseType}}{{end}}, error) {
	var path strings.Builder
	if err := path_{{.Func}}.Execute(&path, r); err != nil {
		return {{if .Stream}}nil, {{end}}nil, err
	}
	{{with .QueryParams -}}
	params := map[string]any{
		{{- range $p, $f := .}}
		"{{$p}}": r.{{$f}},{{end}}
	}
	{{end -}}
	{{if .Stream -}}
	return stream[{{.ResponseType}}](ctx, client, path.String(), {{if .QueryParams}}params{{else}}nil{{end}})
	{{- else -}}
	{{if eq .Method "POST" -}}
	payload := r.Payload
	{{end -}}
	{{if eq .AllocMode 0 -}}
	var response {{.ResponseType}}
	{{else if eq .AllocMode 1 -}}
	response, err := new{{.ResponseType}}(r.Protocol)
	if err != nil {
		return nil, err
	}
	{{else -}}
	response := new({{.ResponseType}})
	{{end -}}
	if err := client.request(ctx, "{{.Method}}", path.String(), {{if .QueryParams}}params{{else}}nil{{end}}, {{if eq .Method "POST" -}}payload{{else}}nil{{end}}, {{if eq .AllocMode 0}}&{{end}}response); err != nil {
		return nil, err
	}
	return response, nil
	{{- end}}
}
{{end}}
`

var tpl = template.Must(template.New("formatter").Parse(tplSrc))

const outName = "request_gen.go"

func main() {
	fd, err := os.Create(outName)
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()
	if err = tpl.Execute(fd, types); err != nil {
		log.Fatal(err)
	}
}
