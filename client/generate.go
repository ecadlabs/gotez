//go:build ignore

package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
	"text/template/parse"
)

type typeDef struct {
	Func         string
	RequestType  string
	Path         string
	Method       string
	ResponseType string
}

var types = []*typeDef{
	{
		RequestType:  "BlockRequest",
		Path:         "/chains/{{.Chain}}/blocks/{{.Block}}",
		Func:         "BlockHeader",
		ResponseType: "protocol.BlockHeader",
	},
}

const tplSrc = `package client

import (
	"context"
	"fmt"
	"github.com/ecadlabs/gotez/protocol"
)

// Code generated by generate.go DO NOT EDIT.
{{range .}}
func (client *Client) {{.Func}}(r *{{.RequestType}}, ctx context.Context) (*{{.ResponseType}}, error) {
	tmp := *r
	if tmp.Chain == "" {
		tmp.Chain = client.Chain
	}
	req := fmt.Sprintf({{.Fmt | printf "%#v"}}{{range .Fields}}, tmp.{{.}}{{end}})
	var response {{.ResponseType}}
	if err := client.request(req, "GET", &response, ctx); err != nil {
		return nil, err
	}
	return &response, nil
}
{{end}}
`

var tpl = template.Must(template.New("formatter").Parse(tplSrc))

const outName = "request_gen.go"

type tplArg struct {
	RequestType  string
	Fmt          string
	Fields       []string
	Func         string
	ResponseType string
}

func main() {
	fd, err := os.Create(outName)
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()

	data := make([]*tplArg, len(types))
	for i, t := range types {
		formatStr, fields, err := parseTemplate(t.Path)
		if err != nil {
			log.Fatal(err)
		}
		data[i] = &tplArg{
			RequestType:  t.RequestType,
			ResponseType: t.ResponseType,
			Fmt:          formatStr,
			Fields:       fields,
			Func:         t.Func,
		}
	}

	if err = tpl.Execute(fd, data); err != nil {
		log.Fatal(err)
	}
}

func parseTemplate(text string) (formatStr string, fields []string, err error) {
	tree, err := parse.Parse("formatter", text, "", "", nil)
	if err != nil {
		return
	}
	root := tree["formatter"].Root
	if root.NodeType != parse.NodeList {
		return "", nil, errors.New("list node expected")
	}

	var fmtStr strings.Builder
	for _, node := range root.Nodes {
		switch node := node.(type) {
		case *parse.TextNode:
			fmtStr.WriteString(string(node.Text))

		case *parse.ActionNode:
			if len(node.Pipe.Cmds) != 1 {
				return "", nil, errors.New("only single pipe command is allowed")
			}
			cmd := node.Pipe.Cmds[0]
			if len(cmd.Args) != 1 {
				return "", nil, errors.New("only single command argument is allowed")
			}
			field, ok := cmd.Args[0].(*parse.FieldNode)
			if !ok {
				return "", nil, errors.New("only field command is allowed")
			}
			fmtStr.WriteString("%v")
			fields = append(fields, strings.Join(field.Ident, "."))

		default:
			return "", nil, fmt.Errorf("unhandled node: %T", node)
		}
	}

	return fmtStr.String(), fields, nil
}
